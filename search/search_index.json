{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#automated-workflow-for-conformer-sampling-and-refinement","title":"Automated Workflow for Conformer Sampling and Refinement.","text":"<p>This repository contains a streamlined Python code for automated ORCA workflow for conformer sampling, TS finding,  and refinement for DFT and MLIPs. The code automates the process of progressively refining the level of theory, eliminating the need for manual intervention. This code seamlessly integrates state-of-the-art MLIP's that can be accessed through ORCA inputs. This code is meant for HPC slurm submission system. Using an input yaml file we are able to automate the process of submitting calculations and then choosing a sampling method to choose the favored conformations, to then refine the calculation with more precise methods.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Automated workflow for conformer sampling and refinement</li> <li>Progressive refinement of computational level across multiple steps</li> <li>Intelligent sampling with multiple selection algorithms (energy window, Boltzmann, integer-based)</li> <li>HPC integration with automatic SLURM job management and resource optimization</li> <li>Built-in analysis with CSV output and structure filtering</li> <li>Flexible configuration via YAML input files</li> <li>Error reduction and efficient resource utilization</li> <li>Machine Learning Interatomic potentials integration using pretrained <code>mace</code> and <code>FairChem models</code> models for fast geometry optimisation, molecular dynamics, and more.</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#development-installation","title":"Development Installation","text":"<pre><code># Clone the repository\ngit clone  https://github.com/sterling-group/ChemRefine.git\ncd ChemRefine\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.6+ with the following dependencies:</li> <li><code>numpy</code> - Numerical computations</li> <li><code>pyyaml</code> - YAML configuration parsing  </li> <li><code>pandas</code> - Data analysis and CSV handling</li> <li><code>ase</code> - Geometry handling and optimisation</li> <li><code>mace-torch</code> - Machine learning force fields</li> <li><code>torch == 2.5.1</code> - Machine Learning (if you use later version of Pytorch it might not work with UMA models)</li> <li>ORCA 6.0+ - Quantum chemistry calculations</li> <li>SLURM - Job scheduling system -MACE-torch - </li> </ul>"},{"location":"#tutorial","title":"Tutorial","text":"<p>You can find examples for running multiple calculations that were in our publication in our Tutorial</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-prepare-input-files","title":"1. Prepare Input Files","text":"<p>Create the required input files in your working directory:</p> <ul> <li>YAML Configuration (<code>input.yaml</code>): Defines the workflow steps</li> <li>Initial XYZ (<code>step1.xyz</code>): Starting molecular geometry  </li> <li>ORCA Templates (<code>step1.inp</code>, <code>step2.inp</code>, <code>step3.inp</code>... <code>orca.slurm.header</code>, <code>mlff.slurm.header</code>): Calculation templates for each step</li> </ul> <p>You must provide one ORCA input file (e.g., <code>step1.inp</code>, <code>step2.inp</code>, etc.) for each step defined in your <code>input.yaml</code> configuration file, otherwise you must define a MLFF step. For example, if your <code>input.yaml</code> specifies three ORCA steps, then you need three corresponding ORCA input files in your templates directory.</p> <p>ChemRefine provides seamless MLIP integration through the use of the tool ExtOpt in Orca, which uses the ORCA optimization codes paired with ASE, you can use any optimization function of ORCA with MLIPS. For more information.</p> <p>In addition to these input files, you must include one of each: - <code>cpu.slurm.header</code>: A SLURM submission script header with your cluster-specific job settings (e.g., partition, time limit, memory). - <code>cuda.slurm.header</code>: Required for MLFF jobs. Include your GPU node configuration here so MLFF calculations run under SLURM.</p> <p>Make sure to specify the path to your ORCA 6.0+ executable in the <code>ORCA_EXEC</code> line of your header file(s). Adjust any other parameters (such as modules or memory) to fit your cluster environment.</p>"},{"location":"#2-run-the-workflow","title":"2. Run the Workflow","text":"<pre><code># Basic usage\nchemrefine input.yaml\n\n# With custom core count\nchemrefine input.yaml --maxcores 128\n\n# Background execution (recommended for HPC)\nnohup chemrefine input.yaml --maxcores 128 &amp;\n\n# Skip any step (if already completed)\nchemrefine input.yaml --skip\n</code></pre>"},{"location":"#3-monitor-progress","title":"3. Monitor Progress","text":"<p>The tool provides detailed logging and creates organized output directories for each step:</p> <pre><code>step1/          # Conformer generation outputs\nstep2/          # First refinement level outputs  \nstep3/          # Final high-level calculations\nsteps.csv       # Summary of energies and structures\n</code></pre>"},{"location":"#chemrefine-operations-and-engines","title":"ChemRefine Operations and Engines","text":""},{"location":"#operations","title":"Operations","text":"Operation Description OPT+SP General optimization followed by a single-point calculation DOCKER Host\u2013guest docking workflow SOLVATOR Explicit solvation for a molecule PES Parse potential energy surface (PES) scan energies MLFF_TRAIN Train or fine-tune a machine-learned force field (MLFF)"},{"location":"#engines","title":"Engines","text":""},{"location":"#1-dft","title":"1. DFT","text":"<ul> <li>Description: Quantum mechanical electronic structure calculations (e.g., ORCA).</li> <li>Usable operations: <code>OPT+SP</code>, <code>DOCKER</code>, <code>SOLVATOR</code>, <code>PES</code></li> </ul>"},{"location":"#2-mlff","title":"2. MLFF","text":"<ul> <li>Description: Machine-learned force fields (fast surrogates for DFT).</li> <li>Usable operations: <code>OPT+SP</code>, <code>DOCKER</code>, <code>SOLVATOR</code>, <code>PES</code>, <code>MLFF_TRAIN</code></li> </ul>"},{"location":"#a-uma-models","title":"(a) UMA Models","text":"Model Variant Task Types (Domain) uma-s-1 omol, oc20, omat, odac, omc uma-s1.1 omol, oc20, omat, odac, omc eSEN-sm-direct omol, oc20, omat, odac, omc eSEN-sm-conserving omol, oc20, omat, odac, omc <p>Task type domains: - omol \u2192 molecules - oc20 \u2192 catalysis - omat \u2192 inorganic materials - odac \u2192 MOFs - omc \u2192 molecular crystals  </p>"},{"location":"#b-mace-models","title":"(b) MACE Models","text":"Task Type Domain / Intended Use mace_off Mace potential trained on SPICE dataset (small,medium,large) mace_omol MACE potential trained on OMol25 (extralarge model) mace_mp MACE potential trained on Inorganic materials (Materials Project)"},{"location":"#input-files-description","title":"Input Files Description","text":""},{"location":"#yaml-configuration-file","title":"YAML Configuration File","text":"<pre><code>template_dir: &lt;location of template_files&gt;\nscratch_dir:  &lt;location of your scratch directory&gt;\noutput_dir: &lt;location of your output directory&gt;\norca_executable: &lt;location of your ORCA executable&gt; \ncharge: 0\nmultiplicity: 1\nsteps:\n  - step: 1\n    template: \"step1.inp\"\n    operation: \"GOAT\"\n    engine: \"DFT\"\n    sampling:\n      method: \"integer\"\n      parameters:\n        count: 10\n  - step: 2\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    charge: -1                  # &lt;--- Step-specific override\n    multiplicity: 2            # &lt;--- Step-specific override\n    sampling:\n      method: \"energy_window\"\n      parameters:\n        window: 0.5\n  - step: 3\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    mlff:\n      model_name: \"medium\"  # For MACE: small,medium,large for FAIRCHEM \"uma-s-1\"\n      task_name: \"mace_off\" # For MACE: \"mace_off\" or \"mace_mp\", for FairChem: oc20, omat, omol, odac, omc\n      bind: '127.0.0.1:8888'    # ChemRefine uses a local server to avoid initializing the model multiple times, only adjust this if you know what you're doing.\n    sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 15 \n      method: \"energy_window\"  \n      parameters:\n        energy: 1  \n        unit: kcal/mol  \n  - step: 3\n    operation: \"SOLVATOR\"\n    engine: \"MLFF\"\n    model_name: \"uma-s-1\"\n    task_name:  \"omol\"\n    sampling:\n      method: \"integer\"\n      parameters:\n        num_structures: 1\n</code></pre> <p>The optional MLFF step uses a pretrained model from <code>mace</code> or <code>FairChem</code>. By default the <code>mace-off</code> backend with the <code>\"medium\"</code> model is used, but you can select different backends and models via <code>model_name</code> and <code>task_type</code>. With task_type you can select on what training data the model was trained on.  If a CUDA-capable GPU is detected, the MLFF optimisation runs on the GPU; otherwise it falls back to the CPU automatically. The optional MLFF step uses a pretrained model from <code>mace</code>. By default the <code>mace-off</code> backend with the <code>\"medium\"</code> model is used, but you can select different backends and models via <code>foundation_model</code> and <code>model_name</code>. If a CUDA-capable GPU is detected, the MLFF optimisation runs on the GPU; otherwise it falls back to the CPU automatically. To avoid downloading the model each time, set the environment variable <code>CHEMREFINE_MLFF_CHECKPOINT</code> to the path of a locally downloaded checkpoint or place the file as <code>chemrefine/models/&lt;model&gt;.model</code> within this repository.</p>"},{"location":"#orca-template-files","title":"ORCA Template Files","text":"<ol> <li>First Input File (<code>step1.inp</code>):</li> <li>Generally includes GOAT specifications for conformer optimization or another conformer sampler. </li> <li>Uses cheap level of theory (e.g., XTB) for initial sampling</li> <li> <p>Example: <code>! GOAT XTB</code></p> </li> <li> <p>Subsequent Input Files (<code>step2.inp</code>, <code>step3.inp</code>, etc.):</p> </li> <li>Progressive refinement with higher-level methods</li> <li>Recommended: Include frequency calculations in final step</li> <li> <p>Example: <code>! B3LYP def2-TZVP FREQ</code></p> </li> <li> <p>Initial XYZ File (<code>step1.xyz</code>):</p> </li> <li>Starting molecular geometry</li> <li>Standard XYZ format with atom count, comment line, and coordinates</li> </ol>"},{"location":"#sampling-methods","title":"Sampling Methods","text":""},{"location":"#energy-window","title":"Energy Window","text":"<pre><code>method: \"energy_window\"\nparameters:\n  window: 0.5  # Hartrees\n</code></pre> <p>Selects conformers within specified energy range of the global minimum.</p>"},{"location":"#boltzmann-population","title":"Boltzmann Population","text":"<pre><code>method: \"boltzmann\"\nparameters:\n  percentage: 95  # Cumulative population %\n</code></pre> <p>Selects conformers based on Boltzmann population at given temperature.</p>"},{"location":"#integer-count","title":"Integer Count","text":"<pre><code>method: \"integer\" \nparameters:\n  count: 10  # Number of conformers\n</code></pre> <p>Selects the N lowest-energy conformers.</p>"},{"location":"#example-multi-step-workflows","title":"Example Multi-Step Workflows","text":"<p>The tool supports complex multi-step refinement protocols: 1. Step 1: GOAT or other conformer generation (XTB level) 2. Step 2: Machine Learning interatomic potential optimization (uma-s-1/omol) 2. Step 3: DFT geometry optimization (B3LYP/def2-SVP) 3. Step 4: High-level single points (B3LYP/def2-TZVP + frequencies)</p>"},{"location":"#resource-management","title":"Resource Management","text":"<ul> <li>Automatic core allocation based on ORCA PAL settings</li> <li>Intelligent job queuing to maximize cluster utilization</li> <li>Real-time monitoring of SLURM job status</li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>auto-conformer-goat/\n\u251c\u2500\u2500 src/chemrefine          # Main package code\n\u251c\u2500\u2500 Examples/               # Example input files and SLURM scripts\n\u251c\u2500\u2500 README.md               # This file\n\u251c\u2500\u2500 LICENSE                 # License\n\u2514\u2500\u2500 pyproject.toml          # Package configuration\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please: 1. Fork the repository 2. Create a feature branch 3. Add tests for new functionality 4. Submit a pull request</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use Auto-Conformer-GOAT in your research, please cite:</p> <pre><code>@software{ChemRefine,\n  title={ChemRefine},\n  author={Sterling Research Group},\n  url={https://github.com/sterling-group/ChemRefine},\n  year={2025}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.</p>"},{"location":"#support","title":"Support","text":"<p>For questions, issues, or feature requests: - \ud83d\udce7 Email: ignacio.migliaro@utdallas.edu - \ud83d\udc1b Issues: GitHub Issues - \ud83d\udcd6 Documentation: README.md</p>"},{"location":"INSTALL/","title":"Installation and Setup Guide","text":""},{"location":"INSTALL/#package-installation","title":"Package Installation","text":""},{"location":"INSTALL/#installation-recommended","title":"Installation (Recommended)","text":"<pre><code>git clone --recursive https://github.com/sterling-research-group/ChemRefine.git\ncd ChemRefine\n\n# Install in development mode\npip install -e .\n\n# Verify installation\nchemrefine --help\n\n# Clone repository\ngit clone https://github.com/sterling-research-group/ChemRefine.git\ncd ChemRefine\n\n# Install package6\npip install .\n</code></pre>"},{"location":"INSTALL/#install-package","title":"Install package","text":"<p>pip install .</p>"},{"location":"INSTALL/#dependencies","title":"Dependencies","text":"<ul> <li>Python 3.6+ with the following dependencies:</li> <li><code>numpy</code> - Numerical computations</li> <li><code>pyyaml</code> - YAML configuration parsing  </li> <li><code>pandas</code> - Data analysis and CSV handling</li> <li><code>ase</code> - Geometry handling and optimisation</li> <li><code>mace-torch</code> - Machine learning force fields</li> <li><code>torch == 2.5.1</code> - Machine Learning (if you use later version of Pytorch it might not work with UMA models)</li> </ul>"},{"location":"INSTALL/#external-requirements","title":"External Requirements","text":"<ul> <li>ORCA 6.0+ - Quantum chemistry calculations</li> <li>SLURM - Job scheduling system for HPC</li> <li>MACE-torch - MLIP platform for MACE architecture</li> <li>FAIRChem - MLIP platform for UMA and esen models</li> </ul>"},{"location":"INSTALL/#verification","title":"Verification","text":"<p>After installation, verify everything works:</p> <pre><code># Test command-line interface\nchemrefine --help\n\n# Test with example files\ncd Examples/\nchemrefine input.yaml --maxcores 32\n</code></pre>"},{"location":"INSTALL/#development-setup","title":"Development Setup","text":"<p>For developers who want to contribute:</p> <pre><code># Install with development dependencies\npip install -e \".\"\n\n# Run tests\npytest\n</code></pre>"},{"location":"INSTALL/#license-information","title":"License Information","text":"<p>This software is licensed under the GNU General Public License v3.0. By installing and using this software, you agree to the terms of the GPL-3.0 license. See the LICENSE file for complete terms.</p>"},{"location":"INSTALL/#troubleshooting","title":"Troubleshooting","text":""},{"location":"INSTALL/#common-issues","title":"Common Issues","text":"<ol> <li>QORCA not found: Ensure submodules are initialized</li> <li>ORCA not accessible: Check ORCA installation and PATH</li> <li>SLURM errors: Verify SLURM configuration for your cluster</li> <li>Permission errors: Check file permissions in working directory</li> </ol>"},{"location":"INSTALL/#getting-help","title":"Getting Help","text":"<ul> <li>Check the main README.md for usage examples</li> <li>Review Examples/ directory for sample inputs</li> <li>Open an issue on GitHub for bugs or feature requests</li> </ul>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>GNU AFFERO GENERAL PUBLIC LICENSE Version 3, 19 November 2007</p> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/</p> <p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p> <pre><code>                        Preamble\n</code></pre> <p>The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software.</p> <p>[... full license text continues here ...]</p> <p>END OF TERMS AND CONDITIONS</p> <p>How to Apply These Terms to Your New Programs</p> <p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \u201ccopyright\u201d line and a pointer to where the full notice is found.</p> <pre><code>&lt;one line to give the program's name and a brief idea of what it does.&gt;\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</code></pre>"},{"location":"tutorials/","title":"Tutorials Overview","text":"<p>This section contains full examples of ChemRefine workflows:</p> <ul> <li>Conformer Sampling</li> <li>Transition State Finding</li> <li>MLIP Training and Normal Mode Sampling</li> <li>Redox properties</li> <li>Host-Guest Docking and Microsolvation</li> <li>Spin Properties</li> </ul>"},{"location":"tutorials/conformer_sampling/","title":"Conformer Sampling Tutorial","text":"<p>This tutorial demonstrates how to use ChemRefine for conformational sampling with an initial global geometry optimization (GOAT) and ensemble generation.</p>"},{"location":"tutorials/conformer_sampling/#overview","title":"Overview","text":"<p>Conformer sampling is the first step in exploring molecular flexibility and generating diverse geometries. ChemRefine automates this process by running a global optimization followed by ensemble generation, producing a set of candidate structures for further refinement.</p> <p>The workflow:</p> <ol> <li>Global Optimization (GOAT):    Performs a stochastic search of the potential energy surface (PES) to identify low-energy conformers.  </li> <li>Ensemble Generation:    Collects the lowest-energy structures into an ensemble for downstream calculations (e.g., DFT, MLFF).</li> <li>Level of theory benchmarking:     We're going to refine the level of theory starting from simple GFN2-xTB, UMA-S-1, PBE-D4, \u03c9B97X-D4, B2PLYP </li> </ol>"},{"location":"tutorials/conformer_sampling/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed ChemRefine (see Installation Guide)  </li> <li>Access to an ORCA executable </li> <li>Example molecule and YAML input from the repository  </li> </ul>"},{"location":"tutorials/conformer_sampling/#input-files","title":"Input Files","text":"<p>For this tutorial, we will use Pd(PPh\u2083)\u2084.</p> <ul> <li>\ud83d\udcc4 View step1.xyz </li> <li>\ud83d\udce5 Download step1.xyz</li> </ul>"},{"location":"tutorials/conformer_sampling/#interactive-3d-viewer","title":"Interactive 3D Viewer","text":""},{"location":"tutorials/conformer_sampling/#yaml-configuration","title":"YAML Configuration","text":"<p>The YAML input for conformer sampling is also included in the tutorial folder:</p> <p>\u27a1\ufe0f Examples/Tutorials/Conformational Sampling/input.yaml</p> <p>Example content:</p> <pre><code>charge: 0\nmultiplicity: 1\n\ninitial_xyz: ./Examples/Tutorials/Conformational Sampling/PdPPh3_4.xyz\n\ntemplate_dir: ./templates\nscratch_dir: /scratch/\noutput_dir: ./outputs\norca_executable: /orca\n# Sequential ORCA Input Configuration File\n# Define each step with its specific parameters.\n#This workflow reflects using GOAT and refining methods to improve the accuracy\ncharge: 0\nmultiplicity: 1 \n\n# Optional: Override default initial structure (default is /template_dir/step1.xyz)\ninitial_xyz: ./templates/step1.xyz\n\nsteps:\n  - step: 1\n    calculation_type: \"GOAT\"\n    sample_type:\n      method: \"integer\"  \n      parameters:\n       num_structures: 15  #This energy is in Hartrees.\n\n  # Step 1: Using MLFF to refine the calculation\n  - step: 2\n    calculation_type: \"MLFF\"\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 15 \n\n  - step: 3\n    calculation_type: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_strucures: 15      \n\n  - step: 4\n    calculation_type: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_strucures: 15\n\n  - step: 5\n    calculation_type: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 15\n</code></pre>"},{"location":"tutorials/conformer_sampling/#how-to-run","title":"How to Run","text":"<p>Before running ChemRefine, ensure that:</p> <ul> <li>The ChemRefine Enviroment is activated</li> <li>The ORCA executable is installed and available in your <code>PATH</code> </li> <li>The template directory (<code>./templates/</code>) is correctly set up  </li> <li>The input structure file (e.g., <code>input.xyz</code>) is prepared  </li> </ul>"},{"location":"tutorials/conformer_sampling/#option-1-run-from-the-command-line","title":"Option 1: Run from the Command Line","text":"<p>You can launch ChemRefine directly from the command line:</p> <pre><code>chemrefine input.yaml --maxcores &lt;N&gt;\n</code></pre> <p>Here N is the max number of simultaneous cores you want to use.</p>"},{"location":"tutorials/conformer_sampling/#option-2-run-chemrefine-with-slurm-script","title":"Option 2: Run ChemRefine with SLURM script","text":"<p>On HPC systems with SLURM, you can submit ChemRefine as a batch job. A ready-to-use SLURM script template is available at:</p> <p>\u27a1\ufe0fExample ChemRefine SLURM script</p> <pre><code>#!/bin/bash\n#SBATCH --partition=&lt;your_partition&gt;\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=1\n#SBATCH --mem=2G              # Limit memory to allow multiple jobs on the same node\n#SBATCH --time=72:00:00\n#SBATCH --exclude=g-07-02\n#SBATCH --job-name=conformer_search\n#SBATCH --output=%x.out   # Saves output to auto_goat_JOBID.out\n#SBATCH --error=%x.err    # Saves error log\n\n# Ensure the script allows for shared node usage\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n# Run the calculation\nchemrefine input.yaml --maxcores 480 \n</code></pre>"},{"location":"tutorials/host-guest/","title":"Host\u2013Guest Docking Tutorial","text":"<p>This tutorial demonstrates how to use ChemRefine for a host\u2013guest docking workflow, followed by machine-learning refinement, DFT validation, and explicit solvation.  </p> <p>We will start with an initial structure (<code>step1.xyz</code>) and progressively refine docking poses through MLFF and DFT optimization.</p>"},{"location":"tutorials/host-guest/#overview","title":"Overview","text":"<ul> <li> <p>Step 1 \u2013 Docking (DFT)   Generate 5 initial docking poses of the guest molecule into the host cavity using XTB-level scoring.</p> </li> <li> <p>Step 2 \u2013 MLFF Optimization   Refine docked structures using the UMA-S-1 MLFF model (<code>omol</code> task).  </p> </li> <li>GPU acceleration is enabled (<code>device: cuda</code>).  </li> <li> <p>Retains structures within 10 kcal/mol of the lowest energy.</p> </li> <li> <p>Step 3 \u2013 DFT Re-optimization   The lowest-energy MLFF structure is re-optimized at the DFT level for accuracy.  </p> </li> <li> <p>Step 4 \u2013 Solvation   Add explicit solvent molecules around the final optimized host\u2013guest complex for solvation analysis.  </p> </li> <li> <p>Step 5 - DFT calculations </p> </li> </ul> <p>DFT calculations for each solvent molecule to get solvation free energies. </p>"},{"location":"tutorials/host-guest/#input-files","title":"Input Files","text":"<p>For this tutorial, we will use the following files.</p> <ul> <li>\ud83d\udcc4 View step1.xyz </li> <li>\ud83d\udce5 Download step1.xyz</li> </ul>"},{"location":"tutorials/host-guest/#interactive-3d-viewer","title":"Interactive 3D Viewer","text":""},{"location":"tutorials/host-guest/#1-input-file","title":"1. Input File","text":"<p>Below is a complete example of an input file (<code>input.yaml</code>) for a docking study:</p> <pre><code>template_dir: ./templates\nscratch_dir: /scratch/ganymede2/dal950773/orca_files/\noutput_dir: ./fixed_charge\norca_executable: /mfs/io/groups/sterling/software-tools/orca/orca_6_1_0_avx2/orca\n\n# Global system settings\ncharge: 0\nmultiplicity: 1\n\n# Optional: Override default initial structure\ninitial_xyz: ./templates/step1.xyz\n\n# === Step-by-step workflow ===\nsteps:\n  # Step 1: Perform docking with DFT\n  - step: 1\n    operation: \"DOCKER\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 5   # Generate 5 docked structures\n\n  # Step 2: Refine docking poses with MLFF\n  - step: 2\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    charge: -1\n    multiplicity: 1\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"energy_window\"\n      parameters:\n        energy: 10\n        unit: kcal/mol\n\n  # Step 3: Validate best candidates with DFT\n  - step: 3\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    charge: -1\n    multiplicity: 1\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 1\n\n  # Step 4: Solvation refinement\n  - step: 4\n    operation: \"SOLVATOR\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 0\n\n  - step: 5\n        engine: \"DFT\"\n        operation: \"OPT+SP\"\n        charge: -1\n        multiplicity: 1\n        sample_type:\n        method: \"energy_window\"\n        parameters:\n            energy: 10\n            unit: kcal/mol\n\n</code></pre>"},{"location":"tutorials/host-guest/#2-running-the-workflow","title":"2. Running the Workflow","text":"<p>From the command line:</p> <pre><code>chemrefine input.yaml --maxcores 16\n</code></pre> <p>This runs the workflow locally with up to 16 parallel jobs.  </p> <p>On an HPC cluster with SLURM:</p> <pre><code>sbatch ./Examples/templates/chemrefine.slurm\n</code></pre>"},{"location":"tutorials/host-guest/#4-expected-outputs","title":"4. Expected Outputs","text":"<ul> <li>Docked poses from Step 1 in <code>outputs/step1/</code> </li> <li>Refined MLFF structures with energies in <code>outputs/step2/</code> </li> <li>Validated DFT structures in <code>outputs/step3/</code> </li> <li>Final solvated complex in <code>outputs/step4/</code> </li> <li>Free Energy Solvation Energies in <code>outputs/step5/</code></li> </ul> <p>Each step directory contains <code>.out</code> logs, <code>.xyz</code> geometries, and summary files.  </p>"},{"location":"tutorials/host-guest/#5-notes-tips","title":"5. Notes &amp; Tips","text":"<ul> <li>Adjust <code>num_structures</code> in Step 1 to explore more docking poses.  </li> <li>Use MLFF refinement for speed, then confirm results with DFT.  </li> <li>Solvation step can be skipped by removing Step 4.  </li> <li>Large jobs should always be submitted via SLURM.  </li> </ul>"},{"location":"tutorials/mlip_training/","title":"MLIP Training Tutorial","text":"<p>This tutorial demonstrates how to use ChemRefine to train a Machine Learning Interatomic Potential (MLIP) using DFT data generated during the workflow.</p>"},{"location":"tutorials/mlip_training/#overview","title":"Overview","text":"<p>Training an MLIP involves generating reference data, running the training process, and validating the trained model on new configurations. ChemRefine automates this multi-step process:</p> <ol> <li> <p>Global Optimization (GOAT)    Performs a global search of the PES to identify low-energy conformers.  </p> </li> <li> <p>Normal Mode Sampling (NMS)    Generates additional diverse geometries by displacing atoms along vibrational modes.  </p> </li> <li> <p>Reference DFT Optimizations (OPT+SP)    Provides high-quality energies and forces for MLIP training.  </p> </li> <li> <p>MLIP Training (MLFF_TRAIN)    Trains a potential (e.g., MACE) on the generated DFT dataset. We will be using MACE to train, as of writing this code (v1.2.1), Chemefine can only train/finetune with MACE. We need a MACE input yaml, explanation can be found here.</p> </li> <li> <p>MLIP Validation (OPT+SP with MLFF)    Applies the trained model to evaluate new structures, testing its accuracy and efficiency.  </p> </li> </ol>"},{"location":"tutorials/mlip_training/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed ChemRefine (see Installation Guide)  </li> <li>Access to an ORCA executable (for DFT reference calculations)  </li> <li>Example molecule and YAML input from the repository  </li> </ul>"},{"location":"tutorials/mlip_training/#input-files","title":"Input Files","text":"<p>We start with an initial structure located in the templates folder:</p> <ul> <li>\ud83d\udcc4 View step1.xyz </li> <li>\ud83d\udce5 Download step1.xyz</li> </ul>"},{"location":"tutorials/mlip_training/#interactive-3d-viewer","title":"Interactive 3D Viewer","text":""},{"location":"tutorials/mlip_training/#yaml-configuration","title":"YAML Configuration","text":"<p>The full YAML input for this MLIP training workflow is included:</p> <p>\u27a1\ufe0f Examples/Tutorials/MLIP-Training/input.yaml</p> <p>Download the template files here</p> <p>Example content:</p> <pre><code>orca_executable: /mfs/io/groups/sterling/software-tools/orca/orca_6_1_0_avx2/orca\ncharge: 0\nmultiplicity: 1\n\ninitial_xyz: ./templates/step1.xyz\n\nsteps:\n  - step: 1\n    operation: \"GOAT\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 15\n\n  - step: 2\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    normal_mode_sampling: True\n    normal_mode_sampling_parameters:\n      calc_type: \"random\"\n      displacement_vector: 1.0\n      num_random_displacements: 1\n    sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 0\n\n  - step: 3\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 0\n\n  - step: 4\n    operation: \"MLFF_TRAIN\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 0\n\n  - step: 5\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    mlff:\n      model_name: \"../step3/checkpoints_dir/goat_model_run-123_stagetwo.model\"\n      task_name: \"mace_off\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 0\n</code></pre>"},{"location":"tutorials/mlip_training/#how-to-run","title":"How to Run","text":"<p>Before running ChemRefine, ensure that:</p> <ul> <li>The ChemRefine environment is activated  </li> <li>The ORCA executable path is correct  </li> <li>The template directory (<code>./templates/</code>) contains the initial structure  </li> <li>The YAML config matches your dataset and workflow  </li> </ul>"},{"location":"tutorials/mlip_training/#option-1-run-from-the-command-line","title":"Option 1: Run from the Command Line","text":"<pre><code>chemrefine input.yaml --maxcores &lt;N&gt;\n</code></pre> <p>Here N is the number of simultaneous cores you want to use.</p>"},{"location":"tutorials/mlip_training/#option-2-run-with-slurm-script","title":"Option 2: Run with SLURM Script","text":"<p>On HPC systems with SLURM, submit the training workflow as a batch script:</p> <p>\u27a1\ufe0f Example ChemRefine SLURM script</p> <pre><code>#!/bin/bash\n#SBATCH --partition=gpu\n#SBATCH --gres=gpu:1\n#SBATCH --cpus-per-task=8\n#SBATCH --mem=32G\n#SBATCH --time=72:00:00\n#SBATCH --job-name=mlip_training\n#SBATCH --output=%x.out\n#SBATCH --error=%x.err\n\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\nchemrefine input.yaml --maxcores 8\n</code></pre>"},{"location":"tutorials/redox/","title":"Redox Reaction Tutorial","text":"<p>This tutorial demonstrates how to use ChemRefine to study redox processes, including electron transfer reactions, charge-state changes, and energy evaluation with both MLFF and DFT levels of theory.</p>"},{"location":"tutorials/redox/#overview","title":"Overview","text":"<p>Redox chemistry is central to catalysis, batteries, and energy materials. ChemRefine automates redox workflows by allowing you to:</p> <ol> <li>Prepare input geometries for different charge states.  </li> <li>Run optimizations at MLFF or DFT levels of theory.  </li> <li>Evaluate redox potentials by comparing total energies of oxidized and reduced species.  </li> <li>Apply solvation corrections if required.  </li> </ol>"},{"location":"tutorials/redox/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed ChemRefine (see Installation Guide)  </li> <li>Access to an ORCA executable </li> <li>Example input (<code>redox_input.yaml</code>) from this tutorial folder  </li> <li>Initial structure (<code>step1.xyz</code>)  </li> </ul>"},{"location":"tutorials/redox/#input-files","title":"Input Files","text":"<p>For this tutorial, we will use the provided redox input file.</p> <ul> <li>\ud83d\udcc4 View redox_input.yaml </li> <li>\ud83d\udce5 Download redox_input.yaml </li> </ul>"},{"location":"tutorials/redox/#interactive-3d-viewer","title":"Interactive 3D Viewer","text":""},{"location":"tutorials/redox/#yaml-configuration","title":"YAML Configuration","text":"<p>\u27a1\ufe0f Examples/Tutorials/Redox/redox_input.yaml</p> <p>Example content (excerpt):</p> <pre><code>template_dir: ./templates\nscratch_dir: /scratch/redox_jobs\noutput_dir: ./outputs/redox\norca_executable: /mfs/io/groups/sterling/software-tools/orca/orca_6_1_0_avx2/orca\n\ncharge: 0\nmultiplicity: 1\n\ninitial_xyz: ./templates/step1.xyz\n\nsteps:\n  - step: 1\n    operation: \"GOAT\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"boltzmann\"  \n      parameters:\n       weight: 95 \n\n  - step: 2\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"energy_window\"\n      parameters:\n        energy: 10      \n        unit: kcal/mol\n\n  - step: 3\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    charge: -1 \n    multiplicity: 2\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"  \n      parameters:\n       num_structures: 0  \n\n  - step: 4\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    charge: 0\n    multiplicity: 1\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"  \n      parameters:\n       num_structures: 0  \n\n  - step: 5\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    charge: 1\n    multiplicity: 2\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"  \n      parameters:\n       num_structures: 0  \n\n  - step: 6\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    charge: -1\n    multiplicity: 2\n    sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 0  \n\n  -  step: 7\n     operation: \"OPT+SP\"\n     engine: \"DFT\"\n     charge: 0\n     multiplicity: 1\n     sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 0  \n\n  -  step: 8\n     operation: \"OPT+SP\"\n     engine: \"DFT\"\n     charge: 1\n     multiplicity: 2\n     sample_type:\n      method: \"integer\"\n      parameters:\n       num_structures: 0  \n</code></pre> <p>This workflow optimizes the neutral, reduced (\u20131), and oxidized (+1) charge states.</p>"},{"location":"tutorials/redox/#how-to-run","title":"How to Run","text":"<p>Before running ChemRefine, ensure that:</p> <ul> <li>The ChemRefine environment is activated  </li> <li>The ORCA executable is in your <code>PATH</code> </li> <li>The template directory (<code>./templates/</code>) is set up  </li> <li>The input structure file (e.g., <code>step1.xyz</code>) is prepared  </li> </ul>"},{"location":"tutorials/redox/#option-1-run-from-the-command-line","title":"Option 1: Run from the Command Line","text":"<pre><code>chemrefine redox_input.yaml --maxcores &lt;N&gt;\n</code></pre> <p>Here <code>&lt;N&gt;</code> is the maximum number of simultaneous cores.  </p>"},{"location":"tutorials/redox/#option-2-run-with-slurm","title":"Option 2: Run with SLURM","text":"<p>On HPC systems with SLURM:</p> <pre><code>sbatch ./Examples/templates/chemrefine.slurm\n</code></pre> <p>\u27a1\ufe0f Example ChemRefine SLURM script</p>"},{"location":"tutorials/redox/#expected-outputs","title":"Expected Outputs","text":"<ul> <li>Neutral optimization in <code>outputs/redox/step1/</code> </li> <li>Reduced state in <code>outputs/redox/step2/</code> </li> <li>Oxidized state in <code>outputs/redox/step3/</code> </li> </ul> <p>Each directory contains <code>.out</code> logs, <code>.xyz</code> geometries, and total energy values. These energies can be compared to compute redox potentials.  </p>"},{"location":"tutorials/redox/#notes-tips","title":"Notes &amp; Tips","text":"<ul> <li>Modify <code>charge</code> and <code>multiplicity</code> values to match your redox states.  </li> <li>Use MLFF first for speed, then recheck with DFT.  </li> <li>Solvation can be included with an additional SOLVATOR step.  </li> <li>Always verify convergence in <code>.out</code> files.  </li> </ul>"},{"location":"tutorials/spin/","title":"Spin State Tutorial","text":"<p>This tutorial demonstrates how to use ChemRefine to investigate different spin states of a molecule and compare predictions between DFT and machine-learned force fields (MLFFs).</p>"},{"location":"tutorials/spin/#overview","title":"Overview","text":"<p>Electronic spin states play a critical role in catalysis, magnetism, and redox chemistry. ChemRefine automates spin exploration with the following workflow:</p> <ol> <li>Initialize geometry from an input structure.  </li> <li>Optimize structures at multiple spin multiplicities.  </li> <li>Compare MLFF vs DFT predictions for spin energetics and geometries.  </li> <li>Extract spin energy gaps for further analysis.  </li> </ol>"},{"location":"tutorials/spin/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed ChemRefine (see Installation Guide)  </li> <li>Access to an ORCA executable </li> <li>Example input (<code>spin_input.yaml</code>) from this tutorial folder  </li> <li>Initial structure (<code>step1.xyz</code>)  </li> </ul>"},{"location":"tutorials/spin/#input-files","title":"Input Files","text":"<p>For this tutorial, we will use the provided spin input file.</p> <ul> <li>\ud83d\udcc4 View spin_input.yaml </li> <li> <p>\ud83d\udce5 Download spin_input.yaml </p> </li> <li> <p>\ud83d\udcc4 View step1.xyz </p> </li> <li>\ud83d\udce5 Download step1.xyz </li> </ul>"},{"location":"tutorials/spin/#interactive-3d-viewer","title":"Interactive 3D Viewer","text":""},{"location":"tutorials/spin/#yaml-configuration","title":"YAML Configuration","text":"<p>\u27a1\ufe0f Examples/Tutorials/Spin/spin_input.yaml</p> <p>Example content (excerpt):</p> <pre><code>template_dir: ./templates\nscratch_dir: /scratch/\noutput_dir: ./outputs\norca_executable: /orca\n\ncharge: 0\nmultiplicity: 5 \n\n# Optional: Override default initial structure (default is /template_dir/step1.xyz)\ninitial_xyz: ./templates/step1.xyz\n\nsteps:\n  - step: 1\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"integer\"  \n      parameters: \n        num_structures: 0\n\n  - step: 2\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    charge: 0 \n    multiplicity: 5\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 0\n\n  - step: 3\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    charge: 0 \n    multiplicity: 3\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 0   \n\n  - step: 4\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    charge: 0 \n    multiplicity: 1\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 0   \n\n  - step: 5\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    charge: 0\n    multiplicity: 5\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"  \n      parameters:\n       num_structures: 0  \n\n  - step: 6\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    charge: 0\n    multiplicity: 3\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"  \n      parameters:\n       num_structures: 0   \n\n  - step: 7\n    operation: \"OPT+SP\"\n    engine: \"MLFF\"\n    charge: 0\n    multiplicity: 1\n    mlff:\n      model_name: \"uma-s-1\"\n      task_name: \"omol\"\n      device: \"cuda\"\n    sample_type:\n      method: \"integer\"  \n      parameters:\n       num_structures: 0  \n</code></pre> <p>This workflow optimizes the same molecule in singlet and triplet spin states using both MLFF and DFT.</p>"},{"location":"tutorials/spin/#how-to-run","title":"How to Run","text":"<p>Before running ChemRefine, ensure that:</p> <ul> <li>The ChemRefine environment is activated  </li> <li>The ORCA executable is in your <code>PATH</code> </li> <li>The template directory (<code>./templates/</code>) is set up  </li> <li>The input structure file (e.g., <code>step1.xyz</code>) is prepared  </li> </ul>"},{"location":"tutorials/spin/#option-1-run-from-the-command-line","title":"Option 1: Run from the Command Line","text":"<pre><code>chemrefine spin_input.yaml --maxcores &lt;N&gt;\n</code></pre> <p>Here <code>&lt;N&gt;</code> is the maximum number of simultaneous cores.  </p>"},{"location":"tutorials/spin/#option-2-run-with-slurm","title":"Option 2: Run with SLURM","text":"<p>On HPC systems with SLURM:</p> <pre><code>sbatch ./Examples/templates/chemrefine.slurm\n</code></pre> <p>\u27a1\ufe0f Example ChemRefine SLURM script</p>"},{"location":"tutorials/spin/#expected-outputs","title":"Expected Outputs","text":"<ul> <li>Singlet optimization (MLFF + DFT) in <code>outputs/spin/step1/</code> and <code>outputs/spin/step2/</code> </li> <li>Triplet optimization (MLFF + DFT) in <code>outputs/spin/step3/</code> and <code>outputs/spin/step4/</code> </li> </ul> <p>Each directory contains <code>.out</code> logs, <code>.xyz</code> geometries, and total energy values. You can compare these to evaluate spin gaps and test MLFF accuracy vs DFT.  </p>"},{"location":"tutorials/spin/#notes-tips","title":"Notes &amp; Tips","text":"<ul> <li>Extend to higher spin states by adding more steps.  </li> <li>Use MLFF first for speed, then benchmark with DFT.  </li> <li>Monitor \u0394E(S=0 \u2192 S=2) to quantify spin crossover energetics.  </li> <li>Spin states may converge to different geometries \u2014 always visualize final <code>.xyz</code> files.  </li> </ul>"},{"location":"tutorials/ts_finding/","title":"Transition State (TS) Finding Tutorial","text":"<p>This tutorial demonstrates how to use ChemRefine to locate and validate transition states (TS) using a stepwise pipeline that combines PES scans, optimizations, frequency analysis, and final single-point energy evaluation.</p>"},{"location":"tutorials/ts_finding/#overview","title":"Overview","text":"<p>Transition states are critical for understanding chemical reactivity and kinetics. ChemRefine automates TS exploration with the following workflow:</p> <ol> <li>PES Scan: Explore bond distances/angles to identify high-energy regions.  </li> <li>TS Optimization (Top 5): Optimize the five highest-energy structures from the PES scan.  </li> <li>Frequency Analysis: Confirm the presence of one imaginary mode.  </li> <li>Imaginary Mode Displacement: Remove the mode and generate corrected geometries.  </li> <li>Final SP Calculation: Compute high-level single-point energies on the corrected TS structure.  </li> </ol>"},{"location":"tutorials/ts_finding/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed ChemRefine (see Installation Guide)  </li> <li>Access to an ORCA executable </li> <li>Example input (<code>ts_input.yaml</code>) from this tutorial folder  </li> <li>Initial structure (<code>step1.xyz</code>)  </li> </ul>"},{"location":"tutorials/ts_finding/#input-files","title":"Input Files","text":"<p>For this tutorial, we will use the provided transition state input file.</p> <ul> <li>\ud83d\udcc4 View ts_input.yaml </li> <li> <p>\ud83d\udce5 Download ts_input.yaml </p> </li> <li> <p>\ud83d\udcc4 View step1.xyz </p> </li> <li>\ud83d\udce5 Download step1.xyz </li> </ul>"},{"location":"tutorials/ts_finding/#interactive-3d-viewer","title":"Interactive 3D Viewer","text":""},{"location":"tutorials/ts_finding/#yaml-configuration","title":"YAML Configuration","text":"<p>\u27a1\ufe0f Examples/Tutorials/Transition-State/ts_input.yaml</p> <p>Example content (excerpt):</p> <pre><code>template_dir: ./templates\nscratch_dir: /scratch/ts_jobs\noutput_dir: ./outputs/ts\norca_executable: /mfs/io/groups/sterling/software-tools/orca/orca_6_1_0_avx2/orca\n\ninitial_xyz: ./templates/step1.xyz\n\nsteps:\n  # Step 1: PES scan\n  - step: 1\n    operation: \"PES\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"integer\"\n      parameters:\n        num_structures: 20\n    constraints:\n      bonds: [(82-91), (0-79), (0-80), (0-82)]\n\n  # Step 2: Optimize top 5 high-energy structures\n  - step: 2\n    operation: \"OPT+SP\"\n    engine: \"DFT\"\n    sample_type:\n      method: \"energy_window\"\n      parameters:\n        energy: top5\n\n  # Step 3: Frequency calculation\n  - step: 3\n    operation: \"FREQ\"\n    engine: \"DFT\"\n\n  # Step 4: Displace along imaginary mode\n  - step: 4\n    operation: \"NORMAL_MODE_SAMPLING\"\n    engine: \"DFT\"\n    parameters:\n      mode: imaginary\n\n  # Step 5: Final SP calculation on corrected TS\n  - step: 5\n    operation: \"SP\"\n    engine: \"DFT\"\n</code></pre>"},{"location":"tutorials/ts_finding/#how-to-run","title":"How to Run","text":"<p>Before running ChemRefine, ensure that:</p> <ul> <li>The ChemRefine environment is activated  </li> <li>The ORCA executable is in your <code>PATH</code> </li> <li>The template directory (<code>./templates/</code>) is set up  </li> <li>The input structure file (e.g., <code>step1.xyz</code>) is prepared  </li> </ul>"},{"location":"tutorials/ts_finding/#option-1-run-from-the-command-line","title":"Option 1: Run from the Command Line","text":"<pre><code>chemrefine ts_input.yaml --maxcores &lt;N&gt;\n</code></pre> <p>Here <code>&lt;N&gt;</code> is the maximum number of simultaneous jobs.  </p>"},{"location":"tutorials/ts_finding/#option-2-run-with-slurm","title":"Option 2: Run with SLURM","text":"<p>On HPC systems with SLURM:</p> <pre><code>sbatch ./Examples/templates/chemrefine.slurm\n</code></pre> <p>\u27a1\ufe0f Example ChemRefine SLURM script</p>"},{"location":"tutorials/ts_finding/#expected-outputs","title":"Expected Outputs","text":"<ul> <li>PES scan geometries in <code>outputs/ts/step1/</code> </li> <li>Top 5 optimized candidates in <code>outputs/ts/step2/</code> </li> <li>Frequency analysis files in <code>outputs/ts/step3/</code> </li> <li>Imaginary mode displacement results in <code>outputs/ts/step4/</code> </li> <li>Final single-point energy in <code>outputs/ts/step5/</code> </li> </ul> <p>Each directory contains <code>.out</code> logs, <code>.xyz</code> geometries, and summary files.  </p>"},{"location":"tutorials/ts_finding/#notes-tips","title":"Notes &amp; Tips","text":"<ul> <li>Increase the PES scan resolution for difficult reactions.  </li> <li>Ensure only one imaginary frequency is present for a valid TS.  </li> <li>Use <code>NORMAL_MODE_SAMPLING</code> to visualize imaginary modes.  </li> <li>Always double-check <code>.xyz</code> files to confirm correct TS geometry.  </li> </ul>"},{"location":"tutorials/ts_finding/#identifying-good-vs-bad-imaginary-modes","title":"Identifying Good vs Bad Imaginary Modes","text":"<p>ChemRefine helps distinguish spurious imaginary modes (bad TS guesses) from true transition states.  </p> <ul> <li> <p>\u274c Bad imaginary frequency: </p> </li> <li> <p>\u2705 Corrected good imaginary frequency: </p> </li> </ul>"}]}